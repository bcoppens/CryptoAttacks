#include <openssl/bn.h>
#include <openssl/ec.h>
#include <openssl/ecdsa.h>
#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <assert.h>
#include <execinfo.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// gcc -g -c -o test-ecdsa.o test-ecdsa.c && gcc -o test-ecdsa-befor test-ecdsa.o -Lopenssl-before/install/lib/ -lcrypto -ldl
// taskset --cpu-list 0 ./ecdsa-ecdsa-befor
static __inline__ unsigned long long rdtsc(void)
{
  unsigned hi, lo;
  __asm__ __volatile__ ("xorl %%eax, %%eax; cpuid; rdtsc" : "=a"(lo), "=d"(hi));
  return ( (unsigned long long)lo)|( ((unsigned long long)hi)<<32 );
}

//#define CALIBRATION

#ifdef CALIBRATION

BIGNUM* group_order;
BIGNUM* generated_k;

#endif 
/*
    We have a fake random generator to see which random k is generated by the EC-DSA code so we can correlate that with our timings
    What we do is the following:
    * Save the random state, and set a custom random number generator.
    * This random number generator looks at whether or not it was called from where the randomness for k is generated. If so, it logs the random k.
    * We reset the random state & original random number generator.
    * We rerun the signing. It will use the same random numbers as before, but we will not have interfered in the execution time at all
*/

// Checks if this is being used for generating a random k. _VERY_ implementation specific! Ahem :(

//   415256:       e8 95 f4 fe ff          callq  4046f0 <BN_rand_range>
// -> this one  41525b:       85 c0                   test   %eax,%eax
//   4197c0:       75 e6                   jne    4197a8 <ecdsa_sign_setup+0x148> # next instruction
int __attribute__ ((noinline)) is_generating_random_k() {
    long* stack;
    __asm__ __volatile__("movq %%rsp, %0" : "=r"(stack));
    return stack[23] == 0x40abee; // #4 in ecdsa_sign_setup
}

/*
    NID_sect163k1 is the NIST Binary-Curve K-163
    NID_sect163r2 is the NIST Binary-Curve B-163
*/
int main(int argc, char** argv) {
    int ret;
    ECDSA_SIG* sig;
    EC_KEY* eckey = EC_KEY_new();
    long long before, after;
    BN_CTX* ctx = NULL;
    BIGNUM* order;
    BIGNUM* m;
    const EC_GROUP* group;
    BIGNUM* x;
    BIGNUM* y;
    const EC_POINT* pubkey;


    char digest[20];
    char test_string[10];
    int i;

    char* bn_dec;

    FILE* theoutputfile = fdopen(1, "w");
    FILE* privatekey = fopen("privatekey", "w");

    if ((ctx=BN_CTX_new()) == NULL) goto err;

    //eckey = EC_KEY_new_by_curve_name(NID_sect163k1);
    eckey = EC_KEY_new_by_curve_name(NID_sect163r2);
    if (eckey == NULL)
        goto err;

    // Generate a public/private key pair
    if (!EC_KEY_generate_key(eckey)) goto err;
    
    order = BN_new();
    if (!order) goto err;

    group = EC_KEY_get0_group(eckey);
    if (!EC_GROUP_get_order(group, order, ctx)) goto err;

    /* Print out the public key too, to be sure & verify */
    x = BN_new(); y = BN_new();
    if (!x || !y) goto err;

    pubkey = EC_KEY_get0_public_key(eckey);
    if (!EC_POINT_get_affine_coordinates_GF2m(group, pubkey, x, y, ctx)) goto err; 

    bn_dec = BN_bn2dec(x);
    fprintf(privatekey, "%s,", bn_dec);
    free(bn_dec);
    bn_dec = BN_bn2dec(y);
    fprintf(privatekey, "%s\n", bn_dec);
    free(bn_dec);

    /* Print out the private key */
    bn_dec = BN_bn2dec(EC_KEY_get0_private_key(eckey));
    fprintf(privatekey, "%s\n", bn_dec);
    free(bn_dec);
    
    m = BN_new();
    if (!m) goto err;
    
    fclose(privatekey);

    for (i = 0; i < 10000; i++) {
        // Digest a 'random' string to sign with SHA-1
        int len = snprintf(test_string, 10, "%i", i);
        SHA1(test_string, len, digest);

        // Compute a ECDSA signature of a SHA-1 hash value using ECDSA_do_sign, time how long it takes
        before = rdtsc();
        sig = ECDSA_do_sign(digest, 20, eckey);
        after = rdtsc();

        if (sig == NULL) {
            goto err;
        }
        
        BN_bin2bn(digest, 20, m);
        
        bn_dec = BN_bn2dec(m);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);


        // We could verify the signature if we wanted (result should be _1_ for a correct result)
        // ret = ECDSA_do_verify(digest, 20, sig, eckey);
        bn_dec = BN_bn2dec(sig->r);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);

        bn_dec = BN_bn2dec(sig->s);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);

        fprintf(theoutputfile, "%lld\n", after - before);


#ifdef CALIBRATION
        bn_dec = BN_bn2dec(generated_k);
        fprintf(theoutputfile, "%i,", log_k);// BN_num_bits(generated_k));
        free(bn_dec);
#endif
    }


    // We're done
err:
    ERR_print_errors_fp(stderr);

    if (eckey) EC_KEY_free(eckey);

    return 0;
}
